<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Parquet</name>
    </assembly>
    <members>
        <member name="M:Thrift.Collections.TCollections.Equals(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            This will return true if the two collections are value-wise the same.
            If the collection contains a collection, the collections will be compared using this method.
            </summary>
        </member>
        <member name="M:Thrift.Collections.TCollections.GetHashCode(System.Collections.IEnumerable)">
            <summary>
            This returns a hashcode based on the value of the enumerable.
            </summary>
        </member>
        <member name="T:Thrift.Protocol.TAbstractBase">
            <summary>
            
            </summary>
        </member>
        <member name="M:Thrift.Protocol.TAbstractBase.Write(Thrift.Protocol.TProtocol)">
            <summary>
            Writes the objects out to the protocol
            </summary>
            <param name="tProtocol"></param>
        </member>
        <member name="M:Thrift.Protocol.TBase.Read(Thrift.Protocol.TProtocol)">
            
             Reads the TObject from the given input protocol.
            
        </member>
        <member name="T:Thrift.Protocol.TBinaryProtocol.Factory">
            Factory
        </member>
        <member name="T:Thrift.Protocol.TCompactProtocol.Types">
            All of the on-wire type codes.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.lastField_">
            Used to keep track of the last field for the current and previous structs,
            so we can do the delta stuff.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.booleanField_">
            If we encounter a boolean field begin, save the TField here so it can
            have the value incorporated.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.boolValue_">
            If we Read a field header, and it's a boolean field, save the boolean
            value here so that ReadBool can use it.
        </member>
        <member name="T:Thrift.Protocol.TCompactProtocol.Factory">
            Factory
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.byteDirectBuffer">
            Writes a byte without any possibility of all that field header nonsense.
            Used internally by other writing methods that know they need to Write a byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteByteDirect(System.Int32)">
            Writes a byte without any possibility of all that field header nonsense.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.i32buf">
            Write an i32 as a varint. Results in 1-5 bytes on the wire.
            TODO: make a permanent buffer like WriteVarint64?
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteMessageBegin(Thrift.Protocol.TMessage)">
            Write a message header to the wire. Compact Protocol messages contain the
            protocol version so we can migrate forwards in the future if need be.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteStructBegin(Thrift.Protocol.TStruct)">
            Write a struct begin. This doesn't actually put anything on the wire. We
            use it as an opportunity to put special placeholder markers on the field
            stack so we can get the field id deltas correct.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteStructEnd">
            Write a struct end. This doesn't actually put anything on the wire. We use
            this as an opportunity to pop the last field from the current struct off
            of the field stack.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Thrift.Protocol.TCompactProtocol.WriteFieldBegin(Thrift.Protocol.TField)" -->
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteFieldBeginInternal(Thrift.Protocol.TField,System.Byte)">
            The workhorse of WriteFieldBegin. It has the option of doing a
            'type override' of the type header. This is used specifically in the
            boolean field case.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteFieldStop">
            Write the STOP symbol so we know there are no more fields in this struct.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteMapBegin(Thrift.Protocol.TMap)">
            Write a map header. If the map is empty, omit the key and value type
            headers, as we don't need any additional information to skip it.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteListBegin(Thrift.Protocol.TList)">
            Write a list header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteSetBegin(Thrift.Protocol.TSet)">
            Write a set header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteBool(System.Boolean)">
            Write a boolean value. Potentially, this could be a boolean field, in
            which case the field header info isn't written yet. If so, decide what the
            right type header is for the value and then Write the field header.
            Otherwise, Write a single byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteByte(System.SByte)">
            Write a byte. Nothing to see here!
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI16(System.Int16)">
            Write an I16 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI32(System.Int32)">
            Write an i32 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteI64(System.Int64)">
            Write an i64 as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteDouble(System.Double)">
            Write a double to the wire as 8 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteString(System.String)">
            Write a string to the wire with a varint size preceding.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteBinary(System.Byte[])">
            Write a byte array, using a varint for the size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.WriteCollectionBegin(Thrift.Protocol.TType,System.Int32)">
            Abstract method for writing the start of lists and sets. List and sets on
            the wire differ only by the type indicator.
        </member>
        <member name="F:Thrift.Protocol.TCompactProtocol.varint64out">
            Write an i64 as a varint. Results in 1-10 bytes on the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.longToZigzag(System.Int64)">
            Convert l into a zigzag long. This allows negative numbers to be
            represented compactly as a varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.intToZigZag(System.Int32)">
            Convert n into a zigzag int. This allows negative numbers to be
            represented compactly as a varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.fixedLongToBytes(System.Int64,System.Byte[],System.Int32)">
            Convert a long into little-endian bytes in buf starting at off and going
            until off+7.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadMessageBegin">
            Read a message header.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadStructBegin">
            Read a struct begin. There's nothing on the wire for this, but it is our
            opportunity to push a new struct begin marker onto the field stack.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadStructEnd">
            Doesn't actually consume any wire data, just removes the last field for
            this struct from the field stack.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadFieldBegin">
            Read a field header off the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadMapBegin">
            Read a map header off the wire. If the size is zero, skip Reading the key
            and value type. This means that 0-length maps will yield TMaps without the
            "correct" types.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadListBegin">
            Read a list header off the wire. If the list size is 0-14, the size will
            be packed into the element type header. If it's a longer list, the 4 MSB
            of the element type header will be 0xF, and a varint will follow with the
            true size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadSetBegin">
            Read a set header off the wire. If the set size is 0-14, the size will
            be packed into the element type header. If it's a longer set, the 4 MSB
            of the element type header will be 0xF, and a varint will follow with the
            true size.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBool">
            Read a boolean off the wire. If this is a boolean field, the value should
            already have been Read during ReadFieldBegin, so we'll just consume the
            pre-stored value. Otherwise, Read a byte.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadByte">
            Read a single byte off the wire. Nothing interesting here.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI16">
            Read an i16 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI32">
            Read an i32 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadI64">
            Read an i64 from the wire as a zigzag varint.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadDouble">
            No magic here - just Read a double off the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadString">
            Reads a byte[] (via ReadBinary), and then UTF-8 decodes it.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBinary">
            Read a byte[] from the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadBinary(System.Int32)">
            Read a byte[] of a known length from the wire.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadVarint32">
            Read an i32 from the wire as a varint. The MSB of each byte is set
            if there is another byte to follow. This can Read up to 5 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.ReadVarint64">
            Read an i64 from the wire as a proper varint. The MSB of each byte is set
            if there is another byte to follow. This can Read up to 10 bytes.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.zigzagToInt(System.UInt32)">
            Convert from zigzag int to int.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.zigzagToLong(System.UInt64)">
            Convert from zigzag long to long.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.bytesToLong(System.Byte[])">
            Note that it's important that the mask bytes are long literals,
            otherwise they'll default to ints, and when you shift an int left 56 bits,
            you just get a messed up int.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.getTType(System.Byte)">
            Given a TCompactProtocol.Types constant, convert it to its corresponding
            TType value.
        </member>
        <member name="M:Thrift.Protocol.TCompactProtocol.getCompactType(Thrift.Protocol.TType)">
            Given a TType value, find the appropriate TCompactProtocol.Types constant.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProcessor">
             TMultiplexedProcessor is a TProcessor allowing a single TServer to provide multiple services.
             To do so, you instantiate the processor and then register additional processors with it,
             as shown in the following example:
            
                 TMultiplexedProcessor processor = new TMultiplexedProcessor();
            
                 processor.registerProcessor(
                     "Calculator",
                     new Calculator.Processor(new CalculatorHandler()));
            
                 processor.registerProcessor(
                     "WeatherReport",
                     new WeatherReport.Processor(new WeatherReportHandler()));
            
                 TServerTransport t = new TServerSocket(9090);
                 TSimpleServer server = new TSimpleServer(processor, t);
            
                 server.serve();
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProcessor.RegisterProcessor(System.String,Thrift.TProcessor)">
             'Register' a service with this TMultiplexedProcessor. This allows us to broker
             requests to individual services by using the service name to select them at request time.
            
             Args:
             - serviceName    Name of a service, has to be identical to the name
                              declared in the Thrift IDL, e.g. "WeatherReport".
             - processor      Implementation of a service, usually referred to as "handlers",
                              e.g. WeatherReportHandler implementing WeatherReport.Iface.
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProcessor.Process(Thrift.Protocol.TProtocol,Thrift.Protocol.TProtocol)">
             This implementation of process performs the following steps:
            
             - Read the beginning of the message.
             - Extract the service name from the message.
             - Using the service name to locate the appropriate processor.
             - Dispatch to the processor, with a decorated instance of TProtocol
                that allows readMessageBegin() to return the original TMessage.
            
             Throws an exception if
             - the message type is not CALL or ONEWAY,
             - the service name was not found in the message, or
             - the service name has not been RegisterProcessor()ed.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProcessor.StoredMessageProtocol">
            Our goal was to work with any protocol.  In order to do that, we needed
            to allow them to call readMessageBegin() and get a TMessage in exactly
            the standard format, without the service name prepended to TMessage.name.
        </member>
        <member name="T:Thrift.Protocol.TMultiplexedProtocol">
             TMultiplexedProtocol is a protocol-independent concrete decorator that allows a Thrift
             client to communicate with a multiplexing Thrift server, by prepending the service name
             to the function name during function calls.
            
             NOTE: THIS IS NOT TO BE USED BY SERVERS.
             On the server, use TMultiplexedProcessor to handle requests from a multiplexing client.
            
             This example uses a single socket transport to invoke two services:
            
                 TSocket transport = new TSocket("localhost", 9090);
                 transport.open();
            
                 TBinaryProtocol protocol = new TBinaryProtocol(transport);
            
                 TMultiplexedProtocol mp = new TMultiplexedProtocol(protocol, "Calculator");
                 Calculator.Client service = new Calculator.Client(mp);
            
                 TMultiplexedProtocol mp2 = new TMultiplexedProtocol(protocol, "WeatherReport");
                 WeatherReport.Client service2 = new WeatherReport.Client(mp2);
            
                 System.out.println(service.add(2,2));
                 System.out.println(service2.getTemperature());
            
        </member>
        <member name="F:Thrift.Protocol.TMultiplexedProtocol.SEPARATOR">
            Used to delimit the service name from the function name 
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProtocol.#ctor(Thrift.Protocol.TProtocol,System.String)">
             Wrap the specified protocol, allowing it to be used to communicate with a
             multiplexing server.  The <code>serviceName</code> is required as it is
             prepended to the message header so that the multiplexing server can broker
             the function call to the proper service.
            
             Args:
              protocol        Your communication protocol of choice, e.g. TBinaryProtocol
              serviceName     The service name of the service communicating via this protocol.
        </member>
        <member name="M:Thrift.Protocol.TMultiplexedProtocol.WriteMessageBegin(Thrift.Protocol.TMessage)">
            Prepends the service name to the function name, separated by TMultiplexedProtocol.SEPARATOR.
            Args:
              tMessage     The original message.
        </member>
        <member name="T:Thrift.Protocol.TProtocolDecorator">
             TProtocolDecorator forwards all requests to an enclosed TProtocol instance,
             providing a way to author concise concrete decorator subclasses.  While it has
             no abstract methods, it is marked abstract as a reminder that by itself,
             it does not modify the behaviour of the enclosed TProtocol.
            
             See p.175 of Design Patterns (by Gamma et al.)
             See TMultiplexedProtocol
        </member>
        <member name="M:Thrift.Protocol.TProtocolDecorator.#ctor(Thrift.Protocol.TProtocol)">
            Encloses the specified protocol.
            @param protocol All operations will be forward to this protocol.  Must be non-null.
        </member>
        <member name="T:Parquet.Attributes.ParquetColumnAttribute">
            <summary>
            Annotates a class property to provide some extra metadata for it.
            </summary>
        </member>
        <member name="M:Parquet.Attributes.ParquetColumnAttribute.#ctor">
            <summary>
            Creates a new instance of the attribute class
            </summary>
        </member>
        <member name="M:Parquet.Attributes.ParquetColumnAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the attribute class specifying column name
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.Name">
            <summary>
            Column name. When undefined a default property name is used which is simply the declared property name on the class.
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.TimeSpanFormat">
            <summary>
            TmeSpanFormat. MilliSeconds or MicroSeconds
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DateTimeFormat">
            <summary>
            DateTimeFormat. Impala or DateAndTime or Date
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalPrecision">
            <summary>
            Precision for decimal fields
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalScale">
            <summary>
            Scale for decimal fields
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.DecimalForceByteArrayEncoding">
            <summary>
            Should this decimal field force byte array encoding?
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.UseListField">
            <summary>
            Should this field be generated as a <see cref="T:Parquet.Data.ListField"/>?
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.ListContainerName">
            <summary>
            Name of the conatiner for the list. Path will be Name.ListContainerName.ListElementName
            </summary>
        </member>
        <member name="P:Parquet.Attributes.ParquetColumnAttribute.ListElementName">
            <summary>
            Name of the element for the list. Path will be Name.ListContainerName.ListElementName
            </summary>
        </member>
        <member name="T:Parquet.Attributes.ParquetIgnoreAttribute">
            <summary>
            Annotates a class property as a marker to ignore while serializing to parquet file
            </summary>
        </member>
        <member name="T:Parquet.CompressionMethod">
            <summary>
            Parquet compression method
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Gzip">
            <summary>
            Gzip compression
            </summary>
        </member>
        <member name="F:Parquet.CompressionMethod.Snappy">
            <summary>
            Snappy compression 
            </summary>
        </member>
        <member name="T:Parquet.Data.ArrayView">
            <summary>
            Encapsulate an array and the length of the array used 
            </summary>
        </member>
        <member name="M:Parquet.Data.BasicDataTypeHandler`1.Compare(`0,`0)">
            <summary>
            less than 0 - x &lt; y
            0 - x == y
            greater than 0 - x &gt; y
            </summary>
        </member>
        <member name="T:Parquet.Data.BasicPrimitiveDataTypeHandler`1">
            <summary>
            Handler for built-in data types in .NET
            </summary>
        </member>
        <member name="M:Parquet.Data.Concrete.BooleanDataTypeHandler.ReadSingle(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Int32)">
            <summary>
            Normally bools are packed, which is implemented in <see cref="M:Parquet.Data.Concrete.BooleanDataTypeHandler.Read(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Array,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Parquet.Data.DataColumn">
            <summary>
            The primary low-level structure to hold data for a parqut column.
            Handles internal data composition/decomposition to enrich with custom data Parquet format requires.
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Data.DataField,System.Array,System.Int32[])">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
            <param name="repetitionLevels"></param>
        </member>
        <member name="M:Parquet.Data.DataColumn.#ctor(Parquet.Data.DataField,System.Array,System.Int32,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="field"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="repetitionLevels"></param>
        </member>
        <member name="P:Parquet.Data.DataColumn.Data">
            <summary>
            Column data where definition levels are already applied
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Offset">
            <summary>
            Offset of the array
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Count">
            <summary>
            Length of the array
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.RepetitionLevels">
            <summary>
            Repetition levels if any.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Field">
            <summary>
            Data field
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.HasRepetitions">
            <summary>
            When true, this field has repetitions. It doesn't mean that it's an array though. This property simply checks that
            repetition levels are present on this column.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumn.Statistics">
            <summary>
            Basic statistics for this data column (populated on read)
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumn.ToString">
            <summary>
            pretty print
            </summary>
        </member>
        <member name="T:Parquet.Data.DataColumnStatistics">
            <summary>
            Basic statistics for data column
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor">
            <summary>
            Creates an uninitalised instance of column statistics
            </summary>
        </member>
        <member name="M:Parquet.Data.DataColumnStatistics.#ctor(System.Int64,System.Int64,System.Object,System.Object)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.NullCount">
            <summary>
            Number of null values
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.DistinctCount">
            <summary>
            Number of distinct values
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MinValue">
            <summary>
            Minimum value, casted to CLR type
            </summary>
        </member>
        <member name="P:Parquet.Data.DataColumnStatistics.MaxValue">
            <summary>
            Maximum value, casted to CLR type
            </summary>
        </member>
        <member name="T:Parquet.Data.DataType">
            <summary>
            List of supported data types
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Unspecified">
            <summary>
            Type is not specified, shouldn't be used.
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Boolean">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Byte">
            <summary>
            Byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.SignedByte">
            <summary>
            Signed byte data type
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedByte">
            <summary>
            Unsigned byte
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Short">
            <summary>
            Short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedShort">
            <summary>
            Unsigned short
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int16">
            <summary>
            16 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt16">
            <summary>
            16 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int32">
            <summary>
            32 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt32">
            <summary>
            32 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int64">
            <summary>
            64 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.UnsignedInt64">
            <summary>
            64 bit unsigned integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Int96">
            <summary>
            96 bit integer
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.ByteArray">
            <summary>
            Array of bytes
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.String">
            <summary>
            UTF-8 string
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Float">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Double">
            <summary>
            Double
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Decimal">
            <summary>
            Decimal
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.DateTimeOffset">
            <summary>
            DateTimeOffset
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.Interval">
            <summary>
            Interval
            </summary>
        </member>
        <member name="F:Parquet.Data.DataType.TimeSpan">
            <summary>
            TimeSpan
            </summary>
        </member>
        <member name="T:Parquet.Data.DateTimeFormat">
            <summary>
            Choice of representing dates
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Impala">
            <summary>
            The impala compatible date, which maps to INT96. This is the default datetime representation.
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.DateAndTime">
            <summary>
            This is the default Parquet datetime representation, but not default option for saving which is <see cref="F:Parquet.Data.DateTimeFormat.Impala"/>.
            Stores date and time up to millisecond precision as INT64
            </summary>
        </member>
        <member name="F:Parquet.Data.DateTimeFormat.Date">
            <summary>
            Only stores a date. Time portion is truncated. Internally stored as INT32
            </summary>
        </member>
        <member name="T:Parquet.Data.DecimalFormatDefaults">
            <summary>
            Pre-defined decimal handling default values; providing backwards compatibility prior to v3.9 where these were made configurable.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultPrecision">
            <summary>
            The Default Precision value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="F:Parquet.Data.DecimalFormatDefaults.DefaultScale">
            <summary>
            The Default Scale value used when not explicitly defined; this is the value used prior to parquet-dotnet v3.9.
            </summary>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.IsMatch(Parquet.Thrift.SchemaElement,Parquet.ParquetOptions)">
            <summary>
            Called by the library to determine if this data handler can be used in current schema position
            </summary>
            <param name="tse"></param>
            <param name="formatOptions"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.Read(System.IO.BinaryReader,Parquet.Thrift.SchemaElement,System.Int32)">
            <summary>
            Reads a single value from the current stream position. This shouldn't be used normally, however it's useful when decoding parquet stats.
            </summary>
            <param name="reader">Incoming data</param>
            <param name="tse">Schema element</param>
            <param name="length">Number of bytes to read (type specific). Pass -1 to read the length from incoming stream if you don't know how long the buffer is.</param>
        </member>
        <member name="M:Parquet.Data.IDataTypeHandler.GetArray(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates or rents a native array
            </summary>
            <param name="minCount">Minimum element count. Realistically there could be more elements than you've asked for only when arrays are rented.</param>
            <param name="rent">Rent or create</param>
            <param name="isNullable">Nullable elements or not</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.DataColumnEnumerator">
            <summary>
            Helps iterating over <see cref="P:Parquet.Data.Rows.DataColumnEnumerator.DataColumn"/> returning either a singular value or an array if the column is repeated.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.LazyColumnEnumerator.ToEnumeratorList">
            <summary>
            Helper method to get all elements as a list of enumerators
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.LazyColumnEnumerator.ReadWindow">
            <summary>
            Reads current element using repetition and definition levels. Given "current" repetiton level
            skips over the nest level to create a "window" over appropriate nesting level. This creates an illusion of
            nested enumerators so that you can build data structures from honestly flat parquet columns.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.Row">
            <summary>
            Represents a tabular row
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class which has only one single column.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.SingleCell(System.Object)">
            <summary>
            Creates a single cell row. Use this method to avoid overloading confusion.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.#ctor(System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Rows.Row"/> class.
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Values">
            <summary>
            Raw values
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Length">
            <summary>
            Gets the number of values in this row
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Row.Item(System.Int32)">
            <summary>
            Gets the row value by index
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetBoolean(System.Int32)">
            <summary>
            Gets the value as boolean
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetInt(System.Int32)">
            <summary>
            Gets the value as integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetFloat(System.Int32)">
            <summary>
            Gets the value as float
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetLong(System.Int32)">
            <summary>
            Gets the value as long
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetDouble(System.Int32)">
            <summary>
            Gets the value as double
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetBigInt(System.Int32)">
            <summary>
            Gets the value as big integer
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetByteArray(System.Int32)">
            <summary>
            Gets the value as byte array
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetString(System.Int32)">
            <summary>
            Gets the value as string
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetDateTimeOffset(System.Int32)">
            <summary>
            Gets the value as <see cref="T:System.DateTimeOffset"/>
            </summary>
            <param name="i">Value index</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.IsNullAt(System.Int32)">
            <summary>
            Returns true if value at column <paramref name="i"/> is NULL.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Get``1(System.Int32)">
            <summary>
            Gets the value trying to cast to <typeparamref name="T"/>
            </summary>
            <param name="i">Value index</param>
            <exception cref="T:System.ArgumentException">Cannot cast <typeparamref name="T"/></exception>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString">
            <summary>
            Converts to internal format string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString(System.String)">
            <summary>
            Convert to string with optional formatting
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.ToString(System.String,System.Int32)">
            <summary>
            Convert to string with optional formatting
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <param name="rowIndex">Optional row index. In case of CSV output, index of 0 prints header row</param>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Equals(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.Equals(Parquet.Data.Rows.Row,System.Boolean)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Row.GetEnumerator">
            <summary>
            Gets object enumerator
            </summary>
        </member>
        <member name="T:Parquet.Data.Rows.RowValidator">
            <summary>
            Everything is rows!!! Not dealing with dictionaries etc. seems like a brilliant idea!!!
            </summary>
        </member>
        <member name="T:Parquet.Data.Rows.Table">
            <summary>
            Represents a table or table chunk that stores data in row format.
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Schema)">
            <summary>
            Creates an empty table with specified schema
            </summary>
            <param name="schema">Parquet file schema.</param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Field[])">
            <summary>
            Creates an empty table with specified fiels as schema
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.#ctor(Parquet.Data.Schema,Parquet.Data.DataColumn[],System.Int64)">
            <summary>
            Creates a table with specified schema
            </summary>
            <param name="schema">Parquet file schema.</param>
            <param name="tableData">Optionally initialise this table with data columns that correspond to the passed <paramref name="schema"/></param>
            <param name="rowCount"></param>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Schema">
            <summary>
            Table schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Parquet.Data.Rows.Table.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Parquet.Data.Rows.Table.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Add(Parquet.Data.Rows.Row)">
            <summary>
            Adds a new row
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Add(System.Object[])">
            <summary>
            Adds a new row from passed cells
            </summary>
            <param name="rowCells"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Clear">
            <summary>
            /
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Contains(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.CopyTo(Parquet.Data.Rows.Row[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.IndexOf(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Insert(System.Int32,Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Remove(Parquet.Data.Rows.Row)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Equals(Parquet.Data.Rows.Table)">
            <summary>
            Compares tables for equality, including:
            - schema equality
            - row count
            - row values equality
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.Equals(Parquet.Data.Rows.Table,System.Boolean)">
            <summary>
            Compares tables for equality, including:
            - schema equality
            - row count
            - row values equality
            </summary>
            <param name="other"></param>
            <param name="throwExceptions"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString">
            <summary>
            Converts table to multiline json. Only shows the first 10 rows as table may be large.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts to string with optional formatting.  Only shows the first 10 rows as table may be large.
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <param name="formatProvider">Optaional format provider, not used at the moment</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Rows.Table.ToString(System.String)">
            <summary>
            Converts to string with optional formatting.  Only shows the first 10 rows as table may be large.
            </summary>
            <param name="format">jsq - one line single-quote json, default, j - one line json</param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.Rows.TableReader">
            <summary>
            Navigates the table
            </summary>
        </member>
        <member name="M:Parquet.Data.Rows.TableReader.#ctor(Parquet.Data.Rows.Table)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.Data.DataField">
            <summary>
            Field containing actual data, unlike fields containing metadata.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.DataType">
            <summary>
            Data type of this element
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.HasNulls">
            <summary>
            When true, this element is allowed to have nulls
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.IsArray">
            <summary>
            When true, the value is an array rather than a single value.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.ClrType">
            <summary>
            CLR type of this column.
            </summary>
        </member>
        <member name="P:Parquet.Data.DataField.ClrNullableIfHasNullsType">
            <summary>
            Unsupported, use at your own risk!
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.#ctor(System.String,System.Type)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.DataField"/> by name and CLR type.
            </summary>
            <param name="name">Field name</param>
            <param name="clrType">CLR type of this field. The type is internally discovered and expanded into appropriate Parquet flags.</param>
        </member>
        <member name="M:Parquet.Data.DataField.#ctor(System.String,Parquet.Data.DataType,System.Boolean,System.Boolean,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.DataField"/> by specifying all the required attributes.
            </summary>
            <param name="name">Field name.</param>
            <param name="dataType">Native Parquet type</param>
            <param name="hasNulls">When true, the field accepts null values. Note that nullable values take slightly more disk space and computing comparing to non-nullable, but are more common.</param>
            <param name="isArray">When true, each value of this field can have multiple values, similar to array in C#.</param>
            <param name="propertyName">When set, uses this property to get the field's data.  When not set, uses the property that matches the name parameter.</param>
        </member>
        <member name="M:Parquet.Data.DataField.PropagateLevels(System.Int32,System.Int32)">
            <summary>
            see
            <see cref="M:Parquet.File.ThriftFooter.GetLevels(Parquet.Thrift.ColumnChunk,System.Int32@,System.Int32@)"/>
            and
            <see cref="M:Parquet.Data.BasicDataTypeHandler`1.CreateSchemaElement(System.Collections.Generic.IList{Parquet.Thrift.SchemaElement},System.Int32@,System.Int32@)"/>
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(Parquet.Data.DataField)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.DataField.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.
            </returns>
        </member>
        <member name="T:Parquet.Data.DataField`1">
            <summary>
            Element of dataset's schema. Provides a helper way to construct a schema element with .NET generics.
            <typeparamref name="T">Type of element in the column</typeparamref>
            </summary>
        </member>
        <member name="M:Parquet.Data.DataField`1.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Field"/> class.
            </summary>
            <param name="name">Column name</param>
        </member>
        <member name="T:Parquet.Data.DateTimeDataField">
            <summary>
            Schema element for <see cref="T:System.DateTimeOffset"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DateTimeDataField.DateTimeFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Data.DateTimeDataField.#ctor(System.String,Parquet.Data.DateTimeFormat,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.DateTimeDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="hasNulls">Is 'DateTime?'</param>
            <param name="isArray"></param>
        </member>
        <member name="T:Parquet.Data.DecimalDataField">
            <summary>
            Maps to Parquet decimal type, allowing to specify custom scale and precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.Scale">
            <summary>
            Scale
            </summary>
        </member>
        <member name="P:Parquet.Data.DecimalDataField.ForceByteArrayEncoding">
            <summary>
            Gets a flag indicating whether byte array encoding is forced.
            </summary>
        </member>
        <member name="M:Parquet.Data.DecimalDataField.#ctor(System.String,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Constructs class instance
            </summary>
            <param name="name">The name of the column</param>
            <param name="precision">Custom precision</param>
            <param name="scale">Custom scale</param>
            <param name="forceByteArrayEncoding">Whether to force decimal type encoding as fixed bytes. Hive and Impala only understands decimals when forced to true.</param>
            <param name="hasNulls">Is 'decimal?'</param>
            <param name="isArray">Indicates whether this field is repeatable.</param>
        </member>
        <member name="T:Parquet.Data.Field">
            <summary>
            Element of dataset's schema
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.SchemaType">
            <summary>
            Type of schema in this field
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Name">
            <summary>
            Column name
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.Path">
            <summary>
            Gets Parquet column path. For non-nested columns always equals to column <see cref="P:Parquet.Data.Field.Name"/> otherwise contains
            a dot (.) separated path to the column within Parquet file. Note that this is a physical path which depends on field
            schema and you shouldn't build any reasonable business logic based on it.
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.MaxRepetitionLevel">
            <summary>
            Max repetition level
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.MaxDefinitionLevel">
            <summary>
            Max definition level
            </summary>
        </member>
        <member name="P:Parquet.Data.Field.ClrPropName">
            <summary>
            Used internally for serialisation
            </summary>
        </member>
        <member name="M:Parquet.Data.Field.#ctor(System.String,Parquet.Data.SchemaType)">
            <summary>
            Constructs a field with only requiremd parameters
            </summary>
            <param name="name">Field name, required</param>
            <param name="schemaType">Type of schema of this field</param>
        </member>
        <member name="M:Parquet.Data.Field.PropagateLevels(System.Int32,System.Int32)">
            <summary>
            Called by schema when field hierarchy is constructed, so that fields can calculate levels as this is
            done in reverse order of construction and needs to be done after data is ready
            </summary>
        </member>
        <member name="M:Parquet.Data.Field.ToString">
            <summary>
            pretty prints
            </summary>
        </member>
        <member name="T:Parquet.Data.ListField">
            <summary>
            Represents a list of items. The list can contain either a normal data field or a complex structure.
            If you need to get a list of primitive data fields it's more efficient to use arrays.
            </summary>
        </member>
        <member name="F:Parquet.Data.ListField.DefaultContainerName">
            <summary>
            Default container name for a list
            </summary>
        </member>
        <member name="P:Parquet.Data.ListField.Item">
            <summary>
            Item contained within this list
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.#ctor(System.String,Parquet.Data.Field,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="item">Field representing list element</param>
            <param name="containerName">Container name</param>
        </member>
        <member name="M:Parquet.Data.ListField.#ctor(System.String,Parquet.Data.DataType,System.Boolean,System.String,System.String,System.String)">
            <summary>
            Creates a new instance of <see cref="T:Parquet.Data.ListField"/>
            </summary>
            <param name="name">Field name</param>
            <param name="dataType">Native Parquet type</param>
            <param name="hasNulls">When true, the field accepts null values. Note that nullable values take slightly more disk space and computing comparing to non-nullable, but are more common.</param>
            <param name="propertyName">When set, uses this property to get the list's data.  When not set, uses the property that matches the name parameter.</param>
            <param name="containerName">Container name</param>
            <param name="elementName">Element name</param>
        </member>
        <member name="M:Parquet.Data.ListField.Equals(Parquet.Data.ListField)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.Equals(System.Object)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Data.ListField.GetHashCode">
            <summary>
            </summary>
        </member>
        <member name="T:Parquet.Data.MapField">
            <summary>
            Implements a dictionary field
            </summary>
        </member>
        <member name="P:Parquet.Data.MapField.Key">
            <summary>
            Data field used as a key
            </summary>
        </member>
        <member name="P:Parquet.Data.MapField.Value">
            <summary>
            Data field used as a value
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.#ctor(System.String,Parquet.Data.DataField,Parquet.Data.DataField)">
            <summary>
            Declares a map field
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.CreateSimpleDictionary">
            <summary>
            Creates an empty dictionary to keep values for this map field. Only works when both key and value are <see cref="T:Parquet.Data.DataField"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.MapField.Equals(System.Object)">
            <summary>
            <see cref="M:Parquet.Data.MapField.Equals(System.Object)"/>
            </summary>
        </member>
        <member name="M:Parquet.Data.MapField.GetHashCode">
            <summary>
            <see cref="M:Parquet.Data.MapField.GetHashCode"/>
            </summary>
        </member>
        <member name="T:Parquet.Data.Schema">
            <summary>
            Represents dataset schema
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparator">
            <summary>
            Symbol used to separate path parts in schema element path
            </summary>
        </member>
        <member name="F:Parquet.Data.Schema.PathSeparatorChar">
            <summary>
            Character used to separate path parts in schema element path
            </summary>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(System.Collections.Generic.IReadOnlyCollection{Parquet.Data.Field})">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class from schema elements.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="M:Parquet.Data.Schema.#ctor(Parquet.Data.Field[])">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.Schema"/> class.
            </summary>
            <param name="fields">The elements.</param>
        </member>
        <member name="P:Parquet.Data.Schema.Fields">
            <summary>
            Gets the schema elements
            </summary>
        </member>
        <member name="P:Parquet.Data.Schema.Item(System.Int32)">
            <summary>
            Get schema element by index
            </summary>
            <param name="i">Index of schema element</param>
            <returns>Schema element</returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetDataFields">
            <summary>
            Gets a flat list of all data fields in this schema
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(Parquet.Data.Schema)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetNotEqualsMessage(Parquet.Data.Schema,System.String,System.String)">
            <summary>
            Compares this schema to <paramref name="other"/> and produces a human readable message describing the differences.
            </summary>
        </member>
        <member name="M:Parquet.Data.Schema.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" />, is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Parquet.Data.Schema.ToString">
            <summary>
            </summary>
        </member>
        <member name="T:Parquet.Data.StructField">
            <summary>
            Represents a structure i.e. a container for other fields.
            </summary>
        </member>
        <member name="M:Parquet.Data.StructField.#ctor(System.String,Parquet.Data.Field[])">
            <summary>
            Creates a new structure field 
            </summary>
            <param name="name">Structure name</param>
            <param name="elements">List of elements</param>
        </member>
        <member name="P:Parquet.Data.StructField.Fields">
            <summary>
            Elements of this structure
            </summary>
        </member>
        <member name="M:Parquet.Data.StructField.Equals(Parquet.Data.StructField)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.StructField.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.Data.StructField.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Parquet.Data.TimeSpanDataField">
            <summary>
            Schema element for <see cref="T:System.TimeSpan"/> which allows to specify precision
            </summary>
        </member>
        <member name="P:Parquet.Data.TimeSpanDataField.TimeSpanFormat">
            <summary>
            Desired data format, Parquet specific
            </summary>
        </member>
        <member name="M:Parquet.Data.TimeSpanDataField.#ctor(System.String,Parquet.Data.TimeSpanFormat,System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Parquet.Data.TimeSpanDataField"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="format">The format.</param>
            <param name="hasNulls">Is 'TimeSpan?'</param>
            <param name="isArray"></param>
        </member>
        <member name="T:Parquet.Data.SchemaType">
            <summary>
            Type of schema
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Data">
            <summary>
            Contains actual values i.e. declared by a <see cref="T:Parquet.Data.DataField"/>
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Map">
            <summary>
            Contains dictionary definition
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.Struct">
            <summary>
            Contains structure definition
            </summary>
        </member>
        <member name="F:Parquet.Data.SchemaType.List">
            <summary>
            Contains list definition
            </summary>
        </member>
        <member name="T:Parquet.Data.TimeSpanFormat">
            <summary>
            Choice of representing time
            </summary>
        </member>
        <member name="F:Parquet.Data.TimeSpanFormat.MilliSeconds">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Data.TimeSpanFormat.MicroSeconds">
            <summary>
            A time.
            
            The total number of microseconds since midnight.  The value is stored as
            an INT64 physical type.
            </summary>
        </member>
        <member name="M:Parquet.CollectionExtensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Batch through IEnumerable without going to the beginning every time. May need optimisations but OK so far.
            </summary>
        </member>
        <member name="T:Parquet.ThriftExtensions">
            <summary>
            Internal thrift data structure helpers
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.CreateGenericList(System.Type)">
            <summary>
            Creates a generic typed list of elements of this type.
            </summary>
        </member>
        <member name="M:Parquet.TypeExtensions.TryExtractEnumerableType(System.Type,System.Type@)">
            <summary>
            Checks if this type implements generic IEnumerable or an array.
            </summary>
            <param name="t"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.File.BytesOwner">
            <summary>
            Provides a back-reference to an allocator which has created the original byte array.
            For instance, if this byte array was rented from a pool, the client won't know how to return it so
            he will just dispose it.
            </summary>
        </member>
        <member name="M:Parquet.File.BytesOwner.ToStream">
            <summary>
            Creates a stream from the current bytes data.
            </summary>
            <remarks>
            Returned stream should be dispose before disposing current object.
            </remarks>
            <returns>
            Stream for bytes represented by current bytes owner instance.
            </returns>
        </member>
        <member name="M:Parquet.File.Streams.IMarkStream.MarkWriteFinished">
            <summary>
            Crappy workaround to mark stream as finished for writing. To be deleted once Snappy supports streaming.
            </summary>
        </member>
        <member name="T:Parquet.File.Streams.SnappyInMemoryStream">
            <summary>
            In-memory hacky implementation of Snappy streaming as Snappy.Sharp's implementation is a work in progress
            </summary>
        </member>
        <member name="T:Parquet.File.StringListComparer">
            <summary>
            Wraps a list of strings and provides equality 
            </summary>
        </member>
        <member name="T:Parquet.File.ThriftStream">
            <summary>
            Utility methods to work with Thrift data in a stream
            </summary>
        </member>
        <member name="M:Parquet.File.ThriftStream.Read``1">
            <summary>
            Reads typed structure from incoming stream
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.File.ThriftStream.Write``1(``0,System.Boolean)">
            <summary>
            Writes types structure to the destination stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="rewind">When true, rewinds to the original position before writing</param>
            <returns>Actual size of the object written</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.BigDecimal">
            <summary>
            A class that encapsulates BigDecimal like the java class
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.DecimalValue">
            <summary>
            Contains a Decimal value that is the big integer
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Scale">
            <summary>
            The scale of the decimal value
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.BigDecimal.Precision">
            <summary>
            The precision of the decimal value
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.op_Implicit(Parquet.File.Values.Primitives.BigDecimal)~System.Decimal">
            <summary>
            Converts a BigDecimal to a decimal
            </summary>
            <param name="bd">The BigDecimal value</param>
        </member>
        <member name="M:Parquet.File.Values.Primitives.BigDecimal.GetBufferSize(System.Int32)">
            <summary>
            Gets buffer size enough to be able to hold the decimal number of a specific precision
            </summary>
            <param name="precision">Precision value</param>
            <returns>Length in bytes</returns>
        </member>
        <member name="T:Parquet.File.Values.Primitives.Interval">
            <summary>
            A parquet interval type compatible with a Spark INTERVAL type
            12 byte little Endian structure fits in an INT96 original type with an INTERVAL converted type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.Primitives.Interval.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Used to create an interval type
            </summary>
            <param name="months">The month interval</param>
            <param name="days">The days interval</param>
            <param name="millis">The milliseconds interval</param>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Millis">
            <summary>
            Returns the number of milliseconds in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Days">
            <summary>
            Returns the number of days in the type
            </summary>
        </member>
        <member name="P:Parquet.File.Values.Primitives.Interval.Months">
            <summary>
            Returns the number of months in type
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadRle(System.Int32,System.IO.BinaryReader,System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>
            Read run-length encoded run from the given header and bit length.
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesReader.ReadUnsignedVarInt(System.IO.BinaryReader)">
            <summary>
            Read a value using the unsigned, variable int encoding.
            </summary>
        </member>
        <member name="M:Parquet.File.Values.RunLengthBitPackingHybridValuesWriter.WriteForwardOnly(System.IO.BinaryWriter,System.Int32,System.Int32[],System.Int32)">
            <summary>
            Writes to target stream without jumping around, therefore can be used in forward-only stream
            </summary>
        </member>
        <member name="T:Parquet.ParquetActor">
            <summary>
            Base class for reader and writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetActor.Stream">
            <summary>
            Original stream to write or read
            </summary>
        </member>
        <member name="T:Parquet.ParquetConvert">
            <summary>
            High-level object oriented API for Apache Parquet
            </summary>
        </member>
        <member name="M:Parquet.ParquetConvert.Serialize``1(System.Collections.Generic.IEnumerable{``0},System.IO.Stream,Parquet.Data.Schema,Parquet.CompressionMethod,System.Int32,System.Boolean)">
            <summary>
            Serialises a collection of classes into a Parquet stream
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="objectInstances">Collection of classes</param>
            <param name="destination">Destination stream</param>
            <param name="schema">Optional schema to use. When not specified the class schema will be discovered and everything possible will be
            written to the stream. If you want to write only a subset of class properties please specify the schema yourself.
            </param>
            <param name="compressionMethod"><see cref="T:Parquet.CompressionMethod"/></param>
            <param name="rowGroupSize"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.Serialize``1(System.Collections.Generic.IEnumerable{``0},System.String,Parquet.Data.Schema,Parquet.CompressionMethod,System.Int32,System.Boolean)">
            <summary>
            Serialises a collection of classes into a Parquet file
            </summary>
            <typeparam name="T">Class type</typeparam>
            <param name="objectInstances">Collection of classes</param>
            <param name="filePath">Destination file path</param>
            <param name="schema">Optional schema to use. When not specified the class schema will be discovered and everything possible will be
            written to the stream. If you want to write only a subset of class properties please specify the schema yourself.
            </param>
            <param name="compressionMethod"><see cref="T:Parquet.CompressionMethod"/></param>
            <param name="rowGroupSize"></param>
            <param name="append"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.Deserialize``1(System.IO.Stream,System.Int32)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="rowGroupIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetConvert.DeserializeGroups``1(System.IO.Stream)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.ParquetException">
            <summary>
            Parquet format specific
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Parquet.ParquetException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="T:Parquet.ParquetExtensions">
            <summary>
            Defines extension methods to simplify Parquet usage (experimental v3)
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.WriteSingleRowGroupParquetFile(System.IO.Stream,Parquet.Data.Schema,Parquet.Data.DataColumn[])">
            <summary>
            Writes a file with a single row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetExtensions.ReadSingleRowGroupParquetFile(System.IO.Stream,Parquet.Data.Schema@,Parquet.Data.DataColumn[]@)">
            <summary>
            Reads the first row group from a file
            </summary>
            <param name="stream"></param>
            <param name="schema"></param>
            <param name="columns"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.Write(Parquet.ParquetWriter,Parquet.Data.Rows.Table)">
            <summary>
            Writes entire table in a single row group
            </summary>
            <param name="writer"></param>
            <param name="table"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.ReadAsTable(Parquet.ParquetReader)">
            <summary>
            Reads the first row group as a table
            </summary>
            <param name="reader">Open reader</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetExtensions.Write(Parquet.ParquetRowGroupWriter,Parquet.Data.Rows.Table)">
            <summary>
            Writes table to this row group
            </summary>
            <param name="writer"></param>
            <param name="table"></param>
        </member>
        <member name="M:Parquet.ParquetExtensions.DecodeSingleStatsValue(Parquet.Thrift.FileMetaData,Parquet.Thrift.ColumnChunk,System.Byte[])">
            <summary>
            Decodes raw bytes from <see cref="T:Parquet.Thrift.Statistics"/> into a CLR value
            </summary>
        </member>
        <member name="T:Parquet.ParquetOptions">
            <summary>
            Parquet options
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatByteArrayAsString">
            <summary>
            When true byte arrays will be treated as UTF-8 strings
            </summary>
        </member>
        <member name="P:Parquet.ParquetOptions.TreatBigIntegersAsDates">
            <summary>
            Gets or sets a value indicating whether big integers are always treated as dates
            </summary>
        </member>
        <member name="T:Parquet.ParquetReader">
            <summary>
            Implements Apache Parquet format reader, experimental version for next major release.
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.#ctor(System.IO.Stream,Parquet.ParquetOptions,System.Boolean)">
            <summary>
            Creates an instance from input stream
            </summary>
            <param name="input">Input stream, must be readable and seekable</param>
            <param name="parquetOptions">Optional reader options</param>
            <param name="leaveStreamOpen">When true, leaves the stream passed in <paramref name="input"/> open after disposing the reader.</param>
            <exception cref="T:System.ArgumentNullException">input</exception>
            <exception cref="T:System.ArgumentException">stream must be readable and seekable - input</exception>
            <exception cref="T:System.IO.IOException">not a Parquet file (size too small)</exception>
        </member>
        <member name="M:Parquet.ParquetReader.OpenFromFile(System.String,Parquet.ParquetOptions)">
            <summary>
            Opens reader from a file on disk. When the reader is disposed the file handle is automatically closed.
            </summary>
            <param name="filePath"></param>
            <param name="parquetOptions"></param>
            <returns></returns>
        </member>
        <member name="P:Parquet.ParquetReader.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadTableFromFile(System.String,Parquet.ParquetOptions)">
            <summary>
            Reads entire file as a table
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.ReadTableFromStream(System.IO.Stream,Parquet.ParquetOptions)">
            <summary>
            Reads entire stream as a table
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.RowGroupCount">
            <summary>
            Gets the number of rows groups in this file
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.Schema">
            <summary>
            Reader schema
            </summary>
        </member>
        <member name="P:Parquet.ParquetReader.ThriftMetadata">
            <summary>
            Internal parquet metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetReader.OpenRowGroupReader(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.ReadEntireRowGroup(System.Int32)">
            <summary>
            Reads entire row group's data columns in one go.
            </summary>
            <param name="rowGroupIndex">Index of the row group. Default to the first row group if not specified.</param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetReader.Dispose">
            <summary>
            Disposes 
            </summary>
        </member>
        <member name="T:Parquet.ParquetRowGroupReader">
            <summary>
            Reader for Parquet row groups
            </summary>
        </member>
        <member name="P:Parquet.ParquetRowGroupReader.RowCount">
            <summary>
            Gets the number of rows in this row group
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.ReadColumn(Parquet.Data.DataField)">
            <summary>
            Reads a column from this row group.
            </summary>
            <param name="field"></param>
            <returns></returns>
        </member>
        <member name="M:Parquet.ParquetRowGroupReader.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.ParquetRowGroupWriter">
            <summary>
            Writer for Parquet row groups
            </summary>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.WriteColumn(Parquet.Data.DataColumn)">
            <summary>
            Writes next data column to parquet stream. Note that columns must be written in the order they are declared in the
            file schema.
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Parquet.ParquetRowGroupWriter.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="T:Parquet.ParquetWriter">
            <summary>
            Implements Apache Parquet format writer
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CompressionMethod">
            <summary>
            Type of compression to use, defaults to <see cref="F:Parquet.CompressionMethod.Snappy"/>
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CompressionLevel">
            <summary>
            Compression level to use, value is treated depending on compression algorithm. Defaults to -1
            meaning default compression level.
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.#ctor(Parquet.Data.Schema,System.IO.Stream,Parquet.ParquetOptions,System.Boolean)">
            <summary>
            Creates an instance of parquet writer on top of a stream
            </summary>
            <param name="schema"></param>
            <param name="output">Writeable, seekable stream</param>
            <param name="formatOptions">Additional options</param>
            <param name="append"></param>
            <exception cref="T:System.ArgumentNullException">Output is null.</exception>
            <exception cref="T:System.ArgumentException">Output stream is not writeable</exception>
        </member>
        <member name="M:Parquet.ParquetWriter.CreateRowGroup">
            <summary>
            Creates a new row group and a writer for it.
            </summary>
        </member>
        <member name="P:Parquet.ParquetWriter.CustomMetadata">
            <summary>
            Gets custom key-value pairs for metadata
            </summary>
        </member>
        <member name="M:Parquet.ParquetWriter.Dispose">
            <summary>
            Disposes the writer and writes the file footer.
            </summary>
        </member>
        <member name="M:Parquet.Serialization.HttpEncoder.JavaScriptStringEncode(System.String)">
            <summary>Encodes a string.</summary>
            <param name="value">The string to encode.</param>
            <returns>An encoded string.</returns>
        </member>
        <member name="T:Parquet.Serialization.ILExtensions">
            <summary>
            Extension methods to simplify MSIL generation
            </summary>
        </member>
        <member name="M:Parquet.Serialization.ILExtensions.CallVirt(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo,System.Object[])">
            <summary>
            
            </summary>
            <param name="il"></param>
            <param name="method"></param>
            <param name="parameters">List of parameters, OpCode and LocalBuilder are supported</param>
        </member>
        <member name="T:Parquet.Serialization.SchemaReflector">
            <summary>
            Infers a class schema using reflection
            </summary>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.#ctor(System.Type)">
            <summary>
            </summary>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Parquet.Serialization.SchemaReflector.Reflect(System.Type)">
            <summary>
            
            </summary>
            <param name="classType"></param>
            <returns></returns>
        </member>
        <member name="T:Parquet.Serialization.Values.ConversionHelpers">
            <summary>
            This class is public to simplify use from Reflection
            </summary>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.DateTimeFromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Convert DateTimeOffset to DateTime
            </summary>
            <param name="value">DateTimeOffset</param>
            <returns>DateTime</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableDateTimeFromDateTimeOffset(System.Nullable{System.DateTimeOffset})">
            <summary>
            Convert DateTimeOffset? to DateTime?
            </summary>
            <param name="value">DateTimeOffset?</param>
            <returns>DateTime?</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableDateTimeOffsetFromDateTime(System.Nullable{System.DateTime})">
            <summary>
            Convert DateTime? to DateTimeOffset?
            </summary>
            <param name="value">DateTime?</param>
            <returns>DateTimeOffset?</returns>
        </member>
        <member name="M:Parquet.Serialization.Values.ConversionHelpers.NullableBooleanToBooleanConversion(System.Nullable{System.Boolean})">
            <summary>
            Convert Boolean? to Boolean
            </summary>
            <param name="value">Boolean?</param>
            <returns>Boolean</returns>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Aad_prefix">
            <summary>
            AAD prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Aad_file_unique">
            <summary>
            Unique file identifier part of AAD suffix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmCtrV1.Supply_aad_prefix">
            <summary>
            In files encrypted with AAD prefix without storing it,
            readers must supply the prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Aad_prefix">
            <summary>
            AAD prefix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Aad_file_unique">
            <summary>
            Unique file identifier part of AAD suffix *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.AesGcmV1.Supply_aad_prefix">
            <summary>
            In files encrypted with AAD prefix without storing it,
            readers must supply the prefix *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterAlgorithm">
            <summary>
            The algorithm used in Bloom filter. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterAlgorithm.BLOCK">
            <summary>
            Block-based Bloom filter. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterHash">
            <summary>
            The hash function used in Bloom filter. This function takes the hash of a column value
            using plain encoding.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHash.XXHASH">
            <summary>
            xxHash Strategy. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BloomFilterHeader">
            <summary>
            Bloom filter header is stored at beginning of Bloom filter data of each column
            and followed by its bitset.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.NumBytes">
            <summary>
            The size of bitset in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Algorithm">
            <summary>
            The algorithm for setting bits. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Hash">
            <summary>
            The hash function used for Bloom filter. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.BloomFilterHeader.Compression">
            <summary>
            The compression used in the Bloom filter *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BoundaryOrder">
            <summary>
            Enum to annotate whether lists of min/max elements inside ColumnIndex
            are ordered and if so, in which direction.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.BsonType">
            <summary>
            Embedded BSON logical type annotation
            
            Allowed for physical types: BINARY
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_path">
            <summary>
            File where column data is stored.  If not set, assumed to be same file as
            metadata.  This path is relative to the current file.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.File_offset">
            <summary>
            Byte offset in file_path to the ColumnMetaData *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Meta_data">
            <summary>
            Column metadata for this chunk. This is the same content as what is at
            file_path/file_offset.  Having it here has it replicated in the file
            metadata.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Offset_index_offset">
            <summary>
            File offset of ColumnChunk's OffsetIndex *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Offset_index_length">
            <summary>
            Size of ColumnChunk's OffsetIndex, in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Column_index_offset">
            <summary>
            File offset of ColumnChunk's ColumnIndex *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Column_index_length">
            <summary>
            Size of ColumnChunk's ColumnIndex, in bytes *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Crypto_metadata">
            <summary>
            Crypto metadata of encrypted columns *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnChunk.Encrypted_column_metadata">
            <summary>
            Encrypted column metadata for this chunk *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnIndex">
            <summary>
            Description for ColumnIndex.
            Each &lt;array-field>[i] refers to the page at OffsetIndex.page_locations[i]
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Null_pages">
            <summary>
            A list of Boolean values to determine the validity of the corresponding
            min and max values. If true, a page contains only null values, and writers
            have to set the corresponding entries in min_values and max_values to
            byte[0], so that all lists have the same length. If false, the
            corresponding entries in min_values and max_values must be valid.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Min_values">
            <summary>
            Two lists containing lower and upper bounds for the values of each page.
            These may be the actual minimum and maximum values found on a page, but
            can also be (more compact) values that do not exist on a page. For
            example, instead of storing ""Blart Versenwald III", a writer may set
            min_values[i]="B", max_values[i]="C". Such more compact values must still
            be valid values within the column's logical type. Readers must make sure
            that list entries are populated before using them by inspecting null_pages.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Boundary_order">
            <summary>
            Stores whether both min_values and max_values are orderd and if so, in
            which direction. This allows readers to perform binary searches in both
            lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even
            if the lists are ordered.
            
            <seealso cref="T:Parquet.Thrift.BoundaryOrder"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnIndex.Null_counts">
            <summary>
            A list containing the number of null values for each page *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnMetaData">
            <summary>
            Description for column metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Type">
            <summary>
            Type of this column *
            
            <seealso cref="P:Parquet.Thrift.ColumnMetaData.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encodings">
            <summary>
            Set of all encodings used for this column. The purpose is to validate
            whether we can decode those pages. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Path_in_schema">
            <summary>
            Path in schema *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Codec">
            <summary>
            Compression codec *
            
            <seealso cref="T:Parquet.Thrift.CompressionCodec"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Num_values">
            <summary>
            Number of values in this column *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_uncompressed_size">
            <summary>
            total byte size of all uncompressed pages in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Total_compressed_size">
            <summary>
            total byte size of all compressed, and potentially encrypted, pages
            in this column chunk (including the headers) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Data_page_offset">
            <summary>
            Byte offset from beginning of file to first data page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Index_page_offset">
            <summary>
            Byte offset from beginning of file to root index page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Dictionary_page_offset">
            <summary>
            Byte offset from the beginning of file to first (only) dictionary page *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Statistics">
            <summary>
            optional statistics for this column chunk
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Encoding_stats">
            <summary>
            Set of all encodings used for pages in this column chunk.
            This information can be used to determine if all data pages are
            dictionary encoded for example *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnMetaData.Bloom_filter_offset">
            <summary>
            Byte offset from beginning of file to Bloom filter data. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ColumnOrder">
            <summary>
            Union to specify the order used for the min_value and max_value fields for a
            column. This union takes the role of an enhanced enum that allows rich
            elements (which will be needed for a collation-based ordering in the future).
            
            Possible values are:
            * TypeDefinedOrder - the column uses the order defined by its logical or
                                 physical type (if there is no logical type).
            
            If the reader does not support the value of this union, min and max stats
            for this column should be ignored.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.ColumnOrder.TYPE_ORDER">
            <summary>
            The sort orders for logical types are:
              UTF8 - unsigned byte-wise comparison
              INT8 - signed comparison
              INT16 - signed comparison
              INT32 - signed comparison
              INT64 - signed comparison
              UINT8 - unsigned comparison
              UINT16 - unsigned comparison
              UINT32 - unsigned comparison
              UINT64 - unsigned comparison
              DECIMAL - signed comparison of the represented value
              DATE - signed comparison
              TIME_MILLIS - signed comparison
              TIME_MICROS - signed comparison
              TIMESTAMP_MILLIS - signed comparison
              TIMESTAMP_MICROS - signed comparison
              INTERVAL - unsigned comparison
              JSON - unsigned byte-wise comparison
              BSON - unsigned byte-wise comparison
              ENUM - unsigned byte-wise comparison
              LIST - undefined
              MAP - undefined
            
            In the absence of logical types, the sort order is determined by the physical type:
              BOOLEAN - false, true
              INT32 - signed comparison
              INT64 - signed comparison
              INT96 (only used for legacy timestamps) - undefined
              FLOAT - signed comparison of the represented value (*)
              DOUBLE - signed comparison of the represented value (*)
              BYTE_ARRAY - unsigned byte-wise comparison
              FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison
            
            (*) Because the sorting order is not specified properly for floating
                point values (relations vs. total ordering) the following
                compatibility rules should be applied when reading statistics:
                - If the min is a NaN, it should be ignored.
                - If the max is a NaN, it should be ignored.
                - If the min is +0, the row group may contain -0 values as well.
                - If the max is -0, the row group may contain +0 values as well.
                - When looking for NaN values, min and max should be ignored.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.CompressionCodec">
            <summary>
            Supported compression algorithms.
            
            Codecs added in 2.4 can be read by readers based on 2.4 and later.
            Codec support may vary between readers based on the format version and
            libraries available at runtime. Gzip, Snappy, and LZ4 codecs are
            widely available, while Zstd and Brotli require additional libraries.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.ConvertedType">
            <summary>
            Common types used by frameworks(e.g. hive, pig) using parquet.  This helps map
            between types in those frameworks to the base types in parquet.  This is only
            metadata and not needed to read or write the data.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UTF8">
            <summary>
            a BYTE_ARRAY actually contains UTF8 encoded chars
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP">
            <summary>
            a map is converted as an optional field containing a repeated key/value pair
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.MAP_KEY_VALUE">
            <summary>
            a key/value pair is converted into a group of two fields
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.LIST">
            <summary>
            a list is converted into an optional field containing a repeated field for its
            values
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.ENUM">
            <summary>
            an enum is converted into a binary field
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DECIMAL">
            <summary>
            A decimal value.
            
            This may be used to annotate binary or fixed primitive types. The
            underlying byte array stores the unscaled value encoded as two's
            complement using big-endian byte order (the most significant byte is the
            zeroth element). The value of the decimal is the value * 10^{-scale}.
            
            This must be accompanied by a (maximum) precision and a scale in the
            SchemaElement. The precision specifies the number of digits in the decimal
            and the scale stores the location of the decimal point. For example 1.23
            would have precision 3 (3 total digits) and scale 2 (the decimal point is
            2 digits over).
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.DATE">
            <summary>
            A Date
            
            Stored as days since Unix epoch, encoded as the INT32 physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIME_MILLIS">
            <summary>
            A time
            
            The total number of milliseconds since midnight.  The value is stored
            as an INT32 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIME_MICROS">
            <summary>
            A time.
            
            The total number of microseconds since midnight.  The value is stored as
            an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIMESTAMP_MILLIS">
            <summary>
            A date/time combination
            
            Date and time recorded as milliseconds since the Unix epoch.  Recorded as
            a physical type of INT64.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.TIMESTAMP_MICROS">
            <summary>
            A date/time combination
            
            Date and time recorded as microseconds since the Unix epoch.  The value is
            stored as an INT64 physical type.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.UINT_8">
            <summary>
            An unsigned integer value.
            
            The number describes the maximum number of meaningful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INT_8">
            <summary>
            A signed integer value.
            
            The number describes the maximum number of meaningful data bits in
            the stored value. 8, 16 and 32 bit values are stored using the
            INT32 physical type.  64 bit values are stored using the INT64
            physical type.
            
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.JSON">
            <summary>
            An embedded JSON document
            
            A JSON document embedded within a single UTF8 column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.BSON">
            <summary>
            An embedded BSON document
            
            A BSON document embedded within a single BINARY column.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.ConvertedType.INTERVAL">
            <summary>
            An interval of time
            
            This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
            This data is composed of three separate little endian unsigned
            integers.  Each stores a component of a duration of time.  The first
            integer identifies the number of months associated with the duration,
            the second identifies the number of days associated with the duration
            and the third identifies the number of milliseconds associated with
            the provided duration.  This duration of time is independent of any
            particular timezone or date.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeader">
            <summary>
            Data page header
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Encoding">
            <summary>
            Encoding used for this data page *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Definition_level_encoding">
            <summary>
            Encoding used for definition levels *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Repetition_level_encoding">
            <summary>
            Encoding used for repetition levels *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeader.Statistics">
            <summary>
            Optional statistics for the data in this page*
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DataPageHeaderV2">
            <summary>
            New page format allowing reading levels without decompressing the data
            Repetition and definition levels are uncompressed
            The remaining section containing the data is compressed if is_compressed is true
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_values">
            <summary>
            Number of values, including NULLs, in this data page. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_nulls">
            <summary>
            Number of NULL values, in this data page.
            Number of non-null = num_values - num_nulls which is also the number of values in the data section *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Num_rows">
            <summary>
            Number of rows in this data page. which means pages change on record boundaries (r = 0) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Encoding">
            <summary>
            Encoding used for data in this page *
            
            <seealso cref="P:Parquet.Thrift.DataPageHeaderV2.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Definition_levels_byte_length">
            <summary>
            length of the definition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Repetition_levels_byte_length">
            <summary>
            length of the repetition levels
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Is_compressed">
            <summary>
            whether the values are compressed.
            Which means the section of the page between
            definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
            is compressed with the compression_codec.
            If missing it is considered compressed
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DataPageHeaderV2.Statistics">
            <summary>
            optional statistics for this column chunk
            </summary>
        </member>
        <member name="T:Parquet.Thrift.DecimalType">
            <summary>
            Decimal logical type annotation
            
            To maintain forward-compatibility in v1, implementations using this logical
            type must also set scale and precision on the annotated SchemaElement.
            
            Allowed for physical types: INT32, INT64, FIXED, and BINARY
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Num_values">
            <summary>
            Number of values in the dictionary *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Encoding">
            <summary>
            Encoding using this dictionary page *
            
            <seealso cref="P:Parquet.Thrift.DictionaryPageHeader.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.DictionaryPageHeader.Is_sorted">
            <summary>
            If true, the entries in the dictionary are sorted in ascending order *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Encoding">
            <summary>
            Encodings supported by Parquet.  Not all encodings are valid for all types.  These
            enums are also used to specify the encoding of definition and repetition levels.
            See the accompanying doc for the details of the more complicated encodings.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN">
            <summary>
            Default encoding.
            BOOLEAN - 1 bit per value. 0 is false; 1 is true.
            INT32 - 4 bytes per value.  Stored as little-endian.
            INT64 - 8 bytes per value.  Stored as little-endian.
            FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
            DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
            BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
            FIXED_LEN_BYTE_ARRAY - Just the bytes.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.PLAIN_DICTIONARY">
            <summary>
            Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
            plain type.
            in a data page use RLE_DICTIONARY instead.
            in a Dictionary page use PLAIN instead
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE">
            <summary>
            Group packed run length encoding. Usable for definition/repetition levels
            encoding and Booleans (on one bit: 0 is false; 1 is true.)
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.BIT_PACKED">
            <summary>
            Bit packed encoding.  This can only be used if the data has a known max
            width.  Usable for definition/repetition levels encoding.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BINARY_PACKED">
            <summary>
            Delta encoding for integers. This can be used for int columns and works best
            on sorted data
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_LENGTH_BYTE_ARRAY">
            <summary>
            Encoding for byte arrays to separate the length values and the data. The lengths
            are encoded using DELTA_BINARY_PACKED
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.DELTA_BYTE_ARRAY">
            <summary>
            Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
            Suffixes are stored as delta length byte arrays.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.RLE_DICTIONARY">
            <summary>
            Dictionary encoding: the ids are encoded using the RLE encoding
            </summary>
        </member>
        <member name="F:Parquet.Thrift.Encoding.BYTE_STREAM_SPLIT">
            <summary>
            Encoding for floating-point data.
            K byte-streams are created where K is the size in bytes of the data type.
            The individual bytes of an FP value are scattered to the corresponding stream and
            the streams are concatenated.
            This itself does not reduce the size of the data but can lead to better compression
            afterwards.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.EncryptionWithColumnKey.Path_in_schema">
            <summary>
            Column path in schema *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.EncryptionWithColumnKey.Key_metadata">
            <summary>
            Retrieval metadata of column encryption key *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FieldRepetitionType">
            <summary>
            Representation of Schemas
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REQUIRED">
            <summary>
            This field is required (can not be null) and each record has exactly 1 value.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.OPTIONAL">
            <summary>
            The field is optional (can be null) and each record has 0 or 1 values.
            </summary>
        </member>
        <member name="F:Parquet.Thrift.FieldRepetitionType.REPEATED">
            <summary>
            The field is repeated and can contain 0 or more values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FileCryptoMetaData">
            <summary>
            Crypto metadata for files with encrypted footer *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileCryptoMetaData.Encryption_algorithm">
            <summary>
            Encryption algorithm. This field is only used for files
            with encrypted footer. Files with plaintext footer store algorithm id
            inside footer (FileMetaData structure).
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileCryptoMetaData.Key_metadata">
            <summary>
            Retrieval metadata of key used for encryption of footer,
            and (possibly) columns *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.FileMetaData">
            <summary>
            Description for file metadata
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Version">
            <summary>
            Version of this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Schema">
            <summary>
            Parquet schema for this file.  This schema contains metadata for all the columns.
            The schema is represented as a tree with a single root.  The nodes of the tree
            are flattened to a list by doing a depth-first traversal.
            The column metadata contains the path in the schema for that column which can be
            used to map columns to nodes in the schema.
            The first element is the root *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Num_rows">
            <summary>
            Number of rows in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Row_groups">
            <summary>
            Row groups in this file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Key_value_metadata">
            <summary>
            Optional key/value metadata *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Created_by">
            <summary>
            String for application that wrote this file.  This should be in the format
            &lt;Application> version &lt;App Version&gt; (build &lt;App Build Hash>).
            e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Column_orders">
            <summary>
            Sort order used for the min_value and max_value fields of each column in
            this file. Sort orders are listed in the order matching the columns in the
            schema. The indexes are not necessary the same though, because only leaf
            nodes of the schema are represented in the list of sort orders.
            
            Without column_orders, the meaning of the min_value and max_value fields is
            undefined. To ensure well-defined behaviour, if min_value and max_value are
            written to a Parquet file, column_orders must be written as well.
            
            The obsolete min and max fields are always sorted by signed comparison
            regardless of column_orders.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Encryption_algorithm">
            <summary>
            Encryption algorithm. This field is set only in encrypted files
            with plaintext footer. Files with encrypted footer store algorithm id
            in FileCryptoMetaData structure.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.FileMetaData.Footer_signing_key_metadata">
            <summary>
            Retrieval metadata of key used for signing the footer.
            Used only in encrypted files with plaintext footer.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.IntType">
            <summary>
            Integer logical type annotation
            
            bitWidth must be 8, 16, 32, or 64.
            
            Allowed for physical types: INT32, INT64
            </summary>
        </member>
        <member name="T:Parquet.Thrift.JsonType">
            <summary>
            Embedded JSON logical type annotation
            
            Allowed for physical types: BINARY
            </summary>
        </member>
        <member name="T:Parquet.Thrift.KeyValue">
            <summary>
            Wrapper struct to store key values
            </summary>
        </member>
        <member name="T:Parquet.Thrift.LogicalType">
            <summary>
            LogicalType annotations to replace ConvertedType.
            
            To maintain compatibility, implementations using LogicalType for a
            SchemaElement must also set the corresponding ConvertedType from the
            following table.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.MilliSeconds">
            <summary>
            Time units for logical types
            </summary>
        </member>
        <member name="T:Parquet.Thrift.NullType">
            <summary>
            Logical type to annotate a column that is always null.
            
            Sometimes when discovering the schema of existing data, values are always
            null and the physical type can't be determined. This annotation signals
            the case where the physical type was guessed from all null values.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.OffsetIndex.Page_locations">
            <summary>
            PageLocations, ordered by increasing PageLocation.offset. It is required
            that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.PageEncodingStats">
            <summary>
            statistics of a given page type and encoding
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Page_type">
            <summary>
            the page type (data/dic/...) *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Encoding">
            <summary>
            encoding of the page *
            
            <seealso cref="P:Parquet.Thrift.PageEncodingStats.Encoding"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageEncodingStats.Count">
            <summary>
            number of pages of this type with this encoding *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Type">
            <summary>
            the type of the page: indicates which of the *_header fields is set *
            
            <seealso cref="T:Parquet.Thrift.PageType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Uncompressed_page_size">
            <summary>
            Uncompressed page size in bytes (not including this header) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Compressed_page_size">
            <summary>
            Compressed (and potentially encrypted) page size in bytes, not including this header *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageHeader.Crc">
            <summary>
            The 32bit CRC for the page, to be be calculated as follows:
            - Using the standard CRC32 algorithm
            - On the data only, i.e. this header should not be included. 'Data'
              hereby refers to the concatenation of the repetition levels, the
              definition levels and the column value, in this exact order.
            - On the encoded versions of the repetition levels, definition levels and
              column values
            - On the compressed versions of the repetition levels, definition levels
              and column values where possible;
              - For v1 data pages, the repetition levels, definition levels and column
                values are always compressed together. If a compression scheme is
                specified, the CRC shall be calculated on the compressed version of
                this concatenation. If no compression scheme is specified, the CRC
                shall be calculated on the uncompressed version of this concatenation.
              - For v2 data pages, the repetition levels and definition levels are
                handled separately from the data and are never compressed (only
                encoded). If a compression scheme is specified, the CRC shall be
                calculated on the concatenation of the uncompressed repetition levels,
                uncompressed definition levels and the compressed column values.
                If no compression scheme is specified, the CRC shall be calculated on
                the uncompressed concatenation.
            If enabled, this allows for disabling checksumming in HDFS if only a few
            pages need to be read.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.Offset">
            <summary>
            Offset of the page in the file *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.Compressed_page_size">
            <summary>
            Size of the page, including header. Sum of compressed_page_size and header
            length
            </summary>
        </member>
        <member name="P:Parquet.Thrift.PageLocation.First_row_index">
            <summary>
            Index within the RowGroup of the first row of the page; this means pages
            change on record boundaries (r = 0).
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Columns">
            <summary>
            Metadata for each column chunk in this row group.
            This list must have the same order as the SchemaElement list in FileMetaData.
            
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Total_byte_size">
            <summary>
            Total byte size of all the uncompressed column data in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Num_rows">
            <summary>
            Number of rows in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Sorting_columns">
            <summary>
            If set, specifies a sort ordering of the rows in this RowGroup.
            The sorting columns can be a subset of all the columns.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.File_offset">
            <summary>
            Byte offset from beginning of file to first page (data or dictionary)
            in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Total_compressed_size">
            <summary>
            Total byte size of all compressed (and potentially encrypted) column data
            in this row group *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.RowGroup.Ordinal">
            <summary>
            Row group ordinal in the file *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SchemaElement">
            <summary>
            Represents a element inside a schema definition.
             - if it is a group (inner node) then type is undefined and num_children is defined
             - if it is a primitive type (leaf) then type is defined and num_children is undefined
            the nodes are listed in depth first traversal order.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type">
            <summary>
            Data type for this field. Not set if the current element is a non-leaf node
            
            <seealso cref="P:Parquet.Thrift.SchemaElement.Type"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Type_length">
            <summary>
            If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.
            Otherwise, if specified, this is the maximum bit length to store any of the values.
            (e.g. a low cardinality INT col could have this set to 3).  Note that this is
            in the schema, and therefore fixed for the entire file.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Repetition_type">
            <summary>
            repetition of the field. The root of the schema does not have a repetition_type.
            All other nodes must have one
            
            <seealso cref="T:Parquet.Thrift.FieldRepetitionType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Name">
            <summary>
            Name of the field in the schema
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Num_children">
            <summary>
            Nested fields.  Since thrift does not support nested fields,
            the nesting is flattened to a single list by a depth-first traversal.
            The children count is used to construct the nested relationship.
            This field is not set when the element is a primitive type
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Converted_type">
            <summary>
            When the schema is the result of a conversion from another model
            Used to record the original type to help with cross conversion.
            
            <seealso cref="T:Parquet.Thrift.ConvertedType"/>
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Scale">
            <summary>
            Used when this column contains decimal data.
            See the DECIMAL converted type for more details.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.Field_id">
            <summary>
            When the original schema supports field ids, this will save the
            original field id in the parquet schema
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SchemaElement.LogicalType">
            <summary>
            The logical type of this SchemaElement
            
            LogicalType replaces ConvertedType, but ConvertedType is still required
            for some logical types to ensure forward-compatibility in format v1.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SortingColumn">
            <summary>
            Wrapper struct to specify sort order
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Column_idx">
            <summary>
            The column index (in this row group) *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Descending">
            <summary>
            If true, indicates this column is sorted in descending order. *
            </summary>
        </member>
        <member name="P:Parquet.Thrift.SortingColumn.Nulls_first">
            <summary>
            If true, nulls will come before non-null values, otherwise,
            nulls go at the end.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.SplitBlockAlgorithm">
            <summary>
            Block-based algorithm type annotation. *
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Statistics">
            <summary>
            Statistics per row group and per page
            All fields are optional.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Max">
            <summary>
            DEPRECATED: min and max value of the column. Use min_value and max_value.
            
            Values are encoded using PLAIN encoding, except that variable-length byte
            arrays do not include a length prefix.
            
            These fields encode min and max values determined by signed comparison
            only. New files should use the correct order for a column's logical type
            and store the values in the min_value and max_value fields.
            
            To support older readers, these may be set when the column order is
            signed.
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Null_count">
            <summary>
            count of null value in the column
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Distinct_count">
            <summary>
            count of distinct values occurring
            </summary>
        </member>
        <member name="P:Parquet.Thrift.Statistics.Max_value">
            <summary>
            Min and max values for the column, determined by its ColumnOrder.
            
            Values are encoded using PLAIN encoding, except that variable-length byte
            arrays do not include a length prefix.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.StringType">
            <summary>
            Empty structs to use as logical type annotations
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TimestampType">
            <summary>
            Timestamp logical type annotation
            
            Allowed for physical types: INT64
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TimeType">
            <summary>
            Time logical type annotation
            
            Allowed for physical types: INT32 (millis), INT64 (micros, nanos)
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Type">
            <summary>
            Types supported by Parquet.  These types are intended to be used in combination
            with the encodings to control the on disk storage format.
            For example INT16 is not included as a type since a good encoding of INT32
            would handle this.
            </summary>
        </member>
        <member name="T:Parquet.Thrift.TypeDefinedOrder">
            <summary>
            Empty struct to signal the order defined by the physical or logical type
            </summary>
        </member>
        <member name="T:Parquet.Thrift.Uncompressed">
            <summary>
            The compression used in the Bloom filter.
            
            </summary>
        </member>
        <member name="T:Parquet.Thrift.XxHash">
            <summary>
            Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
            algorithm. It uses 64 bits version of xxHash.
            
            </summary>
        </member>
    </members>
</doc>
